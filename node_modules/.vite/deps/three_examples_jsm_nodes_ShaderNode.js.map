{
  "version": 3,
  "sources": ["../../three/examples/jsm/nodes/core/constants.js", "../../three/examples/jsm/nodes/core/NodeUtils.js", "../../three/examples/jsm/nodes/core/Node.js", "../../three/examples/jsm/nodes/core/PropertyNode.js", "../../three/examples/jsm/nodes/core/VarNode.js", "../../three/examples/jsm/nodes/core/VaryNode.js", "../../three/examples/jsm/nodes/core/AttributeNode.js", "../../three/examples/jsm/nodes/core/InputNode.js", "../../three/examples/jsm/nodes/core/ConstNode.js", "../../three/examples/jsm/nodes/core/UniformNode.js", "../../three/examples/jsm/nodes/accessors/BufferNode.js", "../../three/examples/jsm/nodes/accessors/Object3DNode.js", "../../three/examples/jsm/nodes/accessors/ModelNode.js", "../../three/examples/jsm/nodes/core/TempNode.js", "../../three/examples/jsm/nodes/core/ExpressionNode.js", "../../three/examples/jsm/nodes/utils/JoinNode.js", "../../three/examples/jsm/nodes/core/NodeUniform.js", "../../three/examples/jsm/nodes/core/NodeAttribute.js", "../../three/examples/jsm/nodes/core/NodeVary.js", "../../three/examples/jsm/nodes/core/NodeVar.js", "../../three/examples/jsm/nodes/core/NodeBuilder.js", "../../three/examples/jsm/nodes/utils/SplitNode.js", "../../three/examples/jsm/nodes/math/OperatorNode.js", "../../three/examples/jsm/nodes/math/MathNode.js", "../../three/examples/jsm/nodes/accessors/PositionNode.js", "../../three/examples/jsm/nodes/accessors/CameraNode.js", "../../three/examples/jsm/nodes/accessors/NormalNode.js", "../../three/examples/jsm/nodes/accessors/UVNode.js", "../../three/examples/jsm/nodes/accessors/TextureNode.js", "../../three/examples/jsm/nodes/core/ContextNode.js", "../../three/examples/jsm/nodes/math/CondNode.js", "../../three/examples/jsm/nodes/utils/ArrayElementNode.js", "../../three/examples/jsm/nodes/utils/ConvertNode.js", "../../three/examples/jsm/nodes/ShaderNode.js"],
  "sourcesContent": ["export const NodeShaderStage = {\n\tVertex: 'vertex',\n\tFragment: 'fragment'\n};\n\nexport const NodeUpdateType = {\n\tNone: 'none',\n\tFrame: 'frame',\n\tObject: 'object'\n};\n\nexport const NodeType = {\n\tBoolean: 'bool',\n\tInteger: 'int',\n\tFloat: 'float',\n\tVector2: 'vec2',\n\tVector3: 'vec3',\n\tVector4: 'vec4',\n\tMatrix3: 'mat3',\n\tMatrix4: 'mat4'\n};\n", "import { Color, Matrix3, Matrix4, Vector2, Vector3, Vector4 } from 'three';\n\nexport const getNodesKeys = ( object ) => {\n\n\tconst props = [];\n\n\tfor ( const name in object ) {\n\n\t\tconst value = object[ name ];\n\n\t\tif ( value && value.isNode === true ) {\n\n\t\t\tprops.push( name );\n\n\t\t}\n\n\t}\n\n\treturn props;\n\n};\n\nexport const getValueType = ( value ) => {\n\n\tif ( typeof value === 'number' ) {\n\n\t\treturn 'float';\n\n\t} else if ( typeof value === 'boolean' ) {\n\n\t\treturn 'bool';\n\n\t} else if ( value?.isVector2 === true ) {\n\n\t\treturn 'vec2';\n\n\t} else if ( value?.isVector3 === true ) {\n\n\t\treturn 'vec3';\n\n\t} else if ( value?.isVector4 === true ) {\n\n\t\treturn 'vec4';\n\n\t} else if ( value?.isMatrix3 === true ) {\n\n\t\treturn 'mat3';\n\n\t} else if ( value?.isMatrix4 === true ) {\n\n\t\treturn 'mat4';\n\n\t} else if ( value?.isColor === true ) {\n\n\t\treturn 'color';\n\n\t}\n\n\treturn null;\n\n};\n\nexport const getValueFromType = ( type, ...params ) => {\n\n\tconst last4 = type?.slice( -4 );\n\n\tif ( type === 'color' ) {\n\n\t\treturn new Color( ...params );\n\n\t} else if ( last4 === 'vec2' ) {\n\n\t\treturn new Vector2( ...params );\n\n\t} else if ( last4 === 'vec3' ) {\n\n\t\treturn new Vector3( ...params );\n\n\t} else if ( last4 === 'vec4' ) {\n\n\t\treturn new Vector4( ...params );\n\n\t} else if ( last4 === 'mat3' ) {\n\n\t\treturn new Matrix3( ...params );\n\n\t} else if ( last4 === 'mat4' ) {\n\n\t\treturn new Matrix4( ...params );\n\n\t} else if ( type === 'bool' ) {\n\n\t\treturn false;\n\n\t} else if ( ( type === 'float' ) || ( type === 'int' ) || ( type === 'uint' ) ) {\n\n\t\treturn 0;\n\n\t}\n\n\treturn null;\n\n};\n", "import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\n\nlet _nodeId = 0;\n\nclass Node {\n\n\tconstructor( nodeType = null ) {\n\n\t\tthis.nodeType = nodeType;\n\n\t\tthis.updateType = NodeUpdateType.None;\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tObject.defineProperty( this, 'id', { value: _nodeId ++ } );\n\n\t}\n\n\tget type() {\n\n\t\treturn this.constructor.name;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn this.uuid;\n\n\t}\n\n\tgetUpdateType( /*builder*/ ) {\n\n\t\treturn this.updateType;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tupdate( /*frame*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tanalyze( builder ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode !== undefined && this !== sharedNode ) {\n\n\t\t\treturn sharedNode.analyze( builder );\n\n\t\t}\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tnodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n\n\t\tconst nodeKeys = getNodesKeys( this );\n\n\t\tfor ( const property of nodeKeys ) {\n\n\t\t\tthis[ property ].analyze( builder );\n\n\t\t}\n\n\t}\n\n\tbuild( builder, output = null ) {\n\n\t\tconst hash = this.getHash( builder );\n\t\tconst sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode !== undefined && this !== sharedNode ) {\n\n\t\t\treturn sharedNode.build( builder, output );\n\n\t\t}\n\n\t\tbuilder.addNode( this );\n\t\tbuilder.addStack( this );\n\n\t\tconst nodeData = builder.getDataFromNode( this );\n\t\tconst isGenerateOnce = this.generate.length === 1;\n\n\t\tlet snippet = null;\n\n\t\tif ( isGenerateOnce ) {\n\n\t\t\tconst type = this.getNodeType( builder );\n\n\t\t\tsnippet = nodeData.snippet;\n\n\t\t\tif ( snippet === undefined ) {\n\n\t\t\t\tsnippet = this.generate( builder ) || '';\n\n\t\t\t\tnodeData.snippet = snippet;\n\n\t\t\t}\n\n\t\t\tsnippet = builder.format( snippet, type, output );\n\n\t\t} else {\n\n\t\t\tsnippet = this.generate( builder, output ) || '';\n\n\t\t}\n\n\t\tbuilder.removeStack( this );\n\n\t\treturn snippet;\n\n\t}\n\n\tserialize( json ) {\n\n\t\tconst nodeKeys = getNodesKeys( this );\n\n\t\tif ( nodeKeys.length > 0 ) {\n\n\t\t\tconst inputNodes = {};\n\n\t\t\tfor ( const property of nodeKeys ) {\n\n\t\t\t\tinputNodes[ property ] = this[ property ].toJSON( json.meta ).uuid;\n\n\t\t\t}\n\n\t\t\tjson.inputNodes = inputNodes;\n\n\t\t}\n\n\t}\n\n\tdeserialize( json ) {\n\n\t\tif ( json.inputNodes !== undefined ) {\n\n\t\t\tconst nodes = json.meta.nodes;\n\n\t\t\tfor ( const property in json.inputNodes ) {\n\n\t\t\t\tconst uuid = json.inputNodes[ property ];\n\n\t\t\t\tthis[ property ] = nodes[ uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst { uuid, type } = this;\n\t\tconst isRoot = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRoot ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t}\n\n\t\t// serialize\n\n\t\tlet data = meta.nodes[ uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tuuid,\n\t\t\t\ttype,\n\t\t\t\tmeta,\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Node',\n\t\t\t\t\tgenerator: 'Node.toJSON'\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmeta.nodes[ data.uuid ] = data;\n\n\t\t\tthis.serialize( data );\n\n\t\t\tdelete data.meta;\n\n\t\t}\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRoot ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\t\t\tif ( nodes.length > 0 ) data.nodes = nodes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nNode.prototype.isNode = true;\n\nexport default Node;\n", "import Node from './Node.js';\n\nclass PropertyNode extends Node {\n\n\tconstructor( name = null, nodeType = 'vec4' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.name = name;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeVary = builder.getVarFromNode( this, this.getNodeType( builder ) );\n\t\tconst name = this.name;\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVary.name = name;\n\n\t\t}\n\n\t\treturn builder.getPropertyName( nodeVary );\n\n\t}\n\n}\n\nexport default PropertyNode;\n", "import Node from './Node.js';\n\nclass VarNode extends Node {\n\n\tconstructor( node, name = null, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn super.getNodeType( builder ) || this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = builder.getVectorType( this.getNodeType( builder ) );\n\t\tconst node = this.node;\n\t\tconst name = this.name;\n\n\t\tconst snippet = node.build( builder, type );\n\t\tconst nodeVar = builder.getVarFromNode( this, type );\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVar.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\treturn propertyName;\n\n\t}\n\n}\n\nVarNode.prototype.isVarNode = true;\n\nexport default VarNode;\n", "import Node from './Node.js';\nimport { NodeShaderStage } from './constants.js';\n\nclass VaryNode extends Node {\n\n\tconstructor( node, name = null ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.name = name;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.name || super.getHash( builder );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\t// VaryNode is auto type\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst node = this.node;\n\t\tconst name = this.name;\n\n\t\tconst nodeVary = builder.getVaryFromNode( this, type );\n\n\t\tif ( name !== null ) {\n\n\t\t\tnodeVary.name = name;\n\n\t\t}\n\n\t\tconst propertyName = builder.getPropertyName( nodeVary, NodeShaderStage.Vertex );\n\n\t\t// force node run in vertex stage\n\t\tbuilder.flowNodeFromShaderStage( NodeShaderStage.Vertex, node, type, propertyName );\n\n\t\treturn builder.getPropertyName( nodeVary );\n\n\t}\n\n}\n\nexport default VaryNode;\n", "import Node from './Node.js';\nimport VaryNode from './VaryNode.js';\n\nclass AttributeNode extends Node {\n\n\tconstructor( attributeName, nodeType ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis._attributeName = attributeName;\n\n\t}\n\n\tgetHash( builder ) {\n\n\t\treturn this.getAttributeName( builder );\n\n\t}\n\n\tsetAttributeName( attributeName ) {\n\n\t\tthis._attributeName = attributeName;\n\n\t\treturn this;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\treturn this._attributeName;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst attribute = builder.getAttribute( this.getAttributeName( builder ), this.getNodeType( builder ) );\n\n\t\tif ( builder.isShaderStage( 'vertex' ) ) {\n\n\t\t\treturn attribute.name;\n\n\t\t} else {\n\n\t\t\tconst nodeVary = new VaryNode( this );\n\n\t\t\treturn nodeVary.build( builder, attribute.type );\n\n\t\t}\n\n\t}\n\n}\n\nexport default AttributeNode;\n", "import Node from './Node.js';\nimport { getValueType, getValueFromType } from './NodeUtils.js';\n\nclass InputNode extends Node {\n\n\tconstructor( value, nodeType = null ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.value = value;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\tif ( this.nodeType === null ) {\n\n\t\t\treturn getValueType( this.value );\n\n\t\t}\n\n\t\treturn this.nodeType;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\treturn this.getNodeType( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value?.toArray?.() || this.value;\n\t\tdata.valueType = getValueType( this.value );\n\t\tdata.nodeType = this.nodeType;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.nodeType = data.nodeType;\n\t\tthis.value = getValueFromType( data.valueType );\n\t\tthis.value = this.value?.fromArray?.( data.value ) || data.value;\n\n\t}\n\n\tgenerate( /*builder, output*/ ) {\n\n\t\tconsole.warn('Abstract function.');\n\n\t}\n\n}\n\nInputNode.prototype.isInputNode = true;\n\nexport default InputNode;\n", "import InputNode from './InputNode.js';\n\nclass ConstNode extends InputNode {\n\n\tgenerateConst( builder ) {\n\n\t\treturn builder.getConst( this.getNodeType( builder ), this.value );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\treturn builder.format( this.generateConst( builder ), type, output );\n\n\t}\n\n}\n\nConstNode.prototype.isConstNode = true;\n\nexport default ConstNode;\n", "import InputNode from './InputNode.js';\n\nclass UniformNode extends InputNode {\n\n\tgetUniformHash( builder ) {\n\n\t\treturn this.getHash( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst hash = this.getUniformHash( builder );\n\n\t\tlet sharedNode = builder.getNodeFromHash( hash );\n\n\t\tif ( sharedNode === undefined ) {\n\n\t\t\tbuilder.setHashNode( this, hash );\n\n\t\t\tsharedNode = this;\n\n\t\t}\n\n\t\tconst sharedNodeType = sharedNode.getInputType( builder );\n\n\t\tconst nodeUniform = builder.getUniformFromNode( sharedNode, builder.shaderStage, sharedNodeType );\n\t\tconst propertyName = builder.getPropertyName( nodeUniform );\n\n\t\treturn builder.format( propertyName, type, output );\n\n\t}\n\n}\n\nUniformNode.prototype.isUniformNode = true;\n\nexport default UniformNode;\n", "import UniformNode from '../core/UniformNode.js';\n\nclass BufferNode extends UniformNode {\n\n\tconstructor( value, bufferType, bufferCount = 0 ) {\n\n\t\tsuper( value, bufferType );\n\n\t\tthis.bufferType = bufferType;\n\t\tthis.bufferCount = bufferCount;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'buffer';\n\n\t}\n\n}\n\nBufferNode.prototype.isBufferNode = true;\n\nexport default BufferNode;\n", "import { Vector3 } from 'three';\nimport Node from '../core/Node.js';\nimport UniformNode from '../core/UniformNode.js';\nimport { NodeUpdateType } from '../core/constants.js';\n\nclass Object3DNode extends Node {\n\n\tstatic VIEW_MATRIX = 'viewMatrix';\n\tstatic NORMAL_MATRIX = 'normalMatrix';\n\tstatic WORLD_MATRIX = 'worldMatrix';\n\tstatic POSITION = 'position';\n\tstatic VIEW_POSITION = 'viewPosition';\n\n\tconstructor( scope = Object3DNode.VIEW_MATRIX, object3d = null ) {\n\n\t\tsuper();\n\n\t\tthis.scope = scope;\n\t\tthis.object3d = object3d;\n\n\t\tthis.updateType = NodeUpdateType.Object;\n\n\t\tthis._uniformNode = new UniformNode( null );\n\n\t}\n\n\tgetNodeType() {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\treturn 'mat3';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\treturn 'vec3';\n\n\t\t}\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst object = this.object3d !== null ? this.object3d : frame.object;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst camera = frame.camera;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\tuniformNode.value = object.modelViewMatrix;\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\tuniformNode.value = object.normalMatrix;\n\n\t\t} else if ( scope === Object3DNode.WORLD_MATRIX ) {\n\n\t\t\tuniformNode.value = object.matrixWorld;\n\n\t\t} else if ( scope === Object3DNode.POSITION ) {\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t} else if ( scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tuniformNode.value.setFromMatrixPosition( object.matrixWorld );\n\n\t\t\tuniformNode.value.applyMatrix4( camera.matrixWorldInverse );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === Object3DNode.WORLD_MATRIX || scope === Object3DNode.VIEW_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t} else if ( scope === Object3DNode.NORMAL_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat3';\n\n\t\t} else if ( scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION ) {\n\n\t\t\tthis._uniformNode.nodeType = 'vec3';\n\t\t\tthis._uniformNode.value = new Vector3();\n\n\t\t}\n\n\t\treturn this._uniformNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default Object3DNode;\n", "import Object3DNode from './Object3DNode.js';\n\nclass ModelNode extends Object3DNode {\n\n\tconstructor( scope = ModelNode.VIEW_MATRIX ) {\n\n\t\tsuper( scope );\n\n\t}\n\n}\n\nexport default ModelNode;\n", "import Node from './Node.js';\n\nclass TempNode extends Node {\n\n\tconstructor( type ) {\n\n\t\tsuper( type );\n\n\t}\n\n\tbuild( builder, output ) {\n\n\t\tconst type = builder.getVectorType( this.getNodeType( builder, output ) );\n\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\tif ( builder.context.temp !== false && type !== 'void ' && output !== 'void' && nodeData.dependenciesCount > 1 ) {\n\n\t\t\tif ( nodeData.snippet === undefined ) {\n\n\t\t\t\tconst snippet = super.build( builder, type );\n\n\t\t\t\tconst nodeVar = builder.getVarFromNode( this, type );\n\t\t\t\tconst propertyName = builder.getPropertyName( nodeVar );\n\n\t\t\t\tbuilder.addFlowCode( `${propertyName} = ${snippet}` );\n\n\t\t\t\tnodeData.snippet = snippet;\n\t\t\t\tnodeData.propertyName = propertyName;\n\n\t\t\t}\n\n\t\t\treturn builder.format( nodeData.propertyName, type, output );\n\n\t\t}\n\n\t\treturn super.build( builder, output );\n\n\t}\n\n}\n\nexport default TempNode;\n", "import TempNode from './TempNode.js';\n\nclass ExpressionNode extends TempNode {\n\n\tconstructor( snipped = '', nodeType = 'void' ) {\n\n\t\tsuper( nodeType );\n\n\t\tthis.snipped = snipped;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst snipped = this.snipped;\n\n\t\tif ( type === 'void' ) {\n\n\t\t\tbuilder.addFlowCode( snipped );\n\n\t\t} else {\n\n\t\t\treturn `( ${ snipped } )`;\n\n\t\t}\n\n\t}\n\n}\n\nexport default ExpressionNode;\n", "import Node from '../core/Node.js';\n\nclass JoinNode extends Node {\n\n\tconstructor( nodes = [] ) {\n\n\t\tsuper();\n\n\t\tthis.nodes = nodes;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.nodes.reduce( ( count, cur ) => count + builder.getTypeLength( cur.getNodeType( builder ) ), 0 ) );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst nodes = this.nodes;\n\n\t\tconst snippetValues = [];\n\n\t\tfor ( let i = 0; i < nodes.length; i ++ ) {\n\n\t\t\tconst input = nodes[ i ];\n\n\t\t\tconst inputSnippet = input.build( builder );\n\n\t\t\tsnippetValues.push( inputSnippet );\n\n\t\t}\n\n\t\treturn `${ builder.getType( type ) }( ${ snippetValues.join( ', ' ) } )`;\n\n\t}\n\n}\n\nexport default JoinNode;\n", "class NodeUniform {\n\n\tconstructor( name, type, node, needsUpdate = undefined ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.node = node;\n\t\tthis.needsUpdate = needsUpdate;\n\n\t}\n\n\tget value() {\n\n\t\treturn this.node.value;\n\n\t}\n\n\tset value( val ) {\n\n\t\tthis.node.value = val;\n\n\t}\n\n}\n\nNodeUniform.prototype.isNodeUniform = true;\n\nexport default NodeUniform;\n", "class NodeAttribute {\n\n\tconstructor( name, type ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nNodeAttribute.prototype.isNodeAttribute = true;\n\nexport default NodeAttribute;\n", "class NodeVary {\n\n\tconstructor( name, type ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nNodeVary.prototype.isNodeVary = true;\n\nexport default NodeVary;\n", "class NodeVar {\n\n\tconstructor( name, type ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\n\t}\n\n}\n\nNodeVar.prototype.isNodeVar = true;\n\nexport default NodeVar;\n", "import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\n\nimport { REVISION, LinearEncoding } from 'three';\n\nexport const shaderStages = [ 'fragment', 'vertex' ];\nexport const vector = [ 'x', 'y', 'z', 'w' ];\n\nconst toFloat = ( value ) => {\n\t\n\tvalue = Number( value );\n\n\treturn value + ( value % 1 ? '' : '.0' );\n\n};\n\nclass NodeBuilder {\n\n\tconstructor( object, renderer, parser ) {\n\n\t\tthis.object = object;\n\t\tthis.material = object.material;\n\t\tthis.renderer = renderer;\n\t\tthis.parser = parser;\n\n\t\tthis.nodes = [];\n\t\tthis.updateNodes = [];\n\t\tthis.hashNodes = {};\n\n\t\tthis.vertexShader = null;\n\t\tthis.fragmentShader = null;\n\n\t\tthis.flowNodes = { vertex: [], fragment: [] };\n\t\tthis.flowCode = { vertex: '', fragment: '' };\n\t\tthis.uniforms = { vertex: [], fragment: [], index: 0 };\n\t\tthis.codes = { vertex: [], fragment: [] };\n\t\tthis.attributes = [];\n\t\tthis.varys = [];\n\t\tthis.vars = { vertex: [], fragment: [] };\n\t\tthis.flow = { code: '' };\n\t\tthis.stack = [];\n\n\t\tthis.context = {\n\t\t\tkeywords: new NodeKeywords(),\n\t\t\tmaterial: object.material\n\t\t};\n\n\t\tthis.nodesData = new WeakMap();\n\t\tthis.flowsData = new WeakMap();\n\n\t\tthis.shaderStage = null;\n\t\tthis.node = null;\n\n\t}\n\n\taddStack( node ) {\n\n\t\t/*\n\t\tif ( this.stack.indexOf( node ) !== - 1 ) {\n\n\t\t\tconsole.warn( 'Recursive node: ', node );\n\n\t\t}\n\t\t*/\n\n\t\tthis.stack.push( node );\n\n\t}\n\n\tremoveStack( node ) {\n\n\t\tconst lastStack = this.stack.pop();\n\n\t\tif ( lastStack !== node ) {\n\n\t\t\tthrow new Error( 'NodeBuilder: Invalid node stack!' );\n\n\t\t}\n\n\t}\n\n\tsetHashNode( node, hash ) {\n\n\t\tthis.hashNodes[ hash ] = node;\n\n\t}\n\n\taddNode( node ) {\n\n\t\tif ( this.nodes.indexOf( node ) === - 1 ) {\n\n\t\t\tconst updateType = node.getUpdateType( this );\n\n\t\t\tif ( updateType !== NodeUpdateType.None ) {\n\n\t\t\t\tthis.updateNodes.push( node );\n\n\t\t\t}\n\n\t\t\tthis.nodes.push( node );\n\n\t\t\tthis.setHashNode( node, node.getHash( this ) );\n\n\t\t}\n\n\t}\n\n\tgetMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetNodeFromHash( hash ) {\n\n\t\treturn this.hashNodes[ hash ];\n\n\t}\n\n\taddFlow( shaderStage, node ) {\n\n\t\tthis.flowNodes[ shaderStage ].push( node );\n\n\t\treturn node;\n\n\t}\n\n\tsetContext( context ) {\n\n\t\tthis.context = context;\n\n\t}\n\n\tgetContext() {\n\n\t\treturn this.context;\n\n\t}\n\n\tgetTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetTextureBias( /* textureProperty, uvSnippet, biasSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTexture( /* textureProperty, uvSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCubeTextureBias( /* textureProperty, uvSnippet, biasSnippet */ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\t// @TODO: rename to .generateConst()\n\tgetConst( type, value ) {\n\n\t\tif ( type === 'float' ) return toFloat( value );\n\t\tif ( type === 'int' ) return `${ Math.round( value ) }`;\n\t\tif ( type === 'uint' ) return value >= 0 ? `${ Math.round( value ) }u` : '0u';\n\t\tif ( type === 'bool' ) return value ? 'true' : 'false';\n\t\tif ( type === 'color' ) return `${ this.getType( 'vec3' ) }( ${ toFloat( value.r ) }, ${ toFloat( value.g ) }, ${ toFloat( value.b ) } )`;\n\n\t\tconst typeLength = this.getTypeLength( type );\n\n\t\tconst componentType = this.getComponentType( type );\n\n\t\tconst getConst = value => this.getConst( componentType, value );\n\n\t\tif ( typeLength === 2 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) } )`;\n\n\t\t} else if ( typeLength === 3 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) } )`;\n\n\t\t} else if ( typeLength === 4 ) {\n\n\t\t\treturn `${ this.getType( type ) }( ${ getConst( value.x ) }, ${ getConst( value.y ) }, ${ getConst( value.z ) }, ${ getConst( value.w ) } )`;\n\n\t\t}\n\n\t\tthrow new Error( `NodeBuilder: Type '${type}' not found in generate constant attempt.` );\n\n\t}\n\n\tgetType( type ) {\n\n\t\treturn type;\n\n\t}\n\n\tgenerateMethod( method ) {\n\n\t\treturn method;\n\n\t}\n\n\tgetAttribute( name, type ) {\n\n\t\tconst attributes = this.attributes;\n\n\t\t// find attribute\n\n\t\tfor ( const attribute of attributes ) {\n\n\t\t\tif ( attribute.name === name ) {\n\n\t\t\t\treturn attribute;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create a new if no exist\n\n\t\tconst attribute = new NodeAttribute( name, type );\n\n\t\tattributes.push( attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\tgetPropertyName( node/*, shaderStage*/ ) {\n\n\t\treturn node.name;\n\n\t}\n\n\tisVector( type ) {\n\n\t\treturn /vec\\d/.test( type );\n\n\t}\n\n\tisMatrix( type ) {\n\n\t\treturn /mat\\d/.test( type );\n\n\t}\n\n\tisReference( type ) {\n\n\t\treturn type === 'void' || type === 'property' || type === 'sampler';\n\n\t}\n\n\tisShaderStage( shaderStage ) {\n\n\t\treturn this.shaderStage === shaderStage;\n\n\t}\n\n\tgetTextureEncodingFromMap( map ) {\n\n\t\tlet encoding;\n\n\t\tif ( map && map.isTexture ) {\n\n\t\t\tencoding = map.encoding;\n\n\t\t} else if ( map && map.isWebGLRenderTarget ) {\n\n\t\t\tencoding = map.texture.encoding;\n\n\t\t} else {\n\n\t\t\tencoding = LinearEncoding;\n\n\t\t}\n\n\t\treturn encoding;\n\n\t}\n\n\tgetComponentType( type ) {\n\n\t\ttype = this.getVectorType( type );\n\n\t\tconst componentType = /(b|i|u|)(vec|mat)([2-4])/.exec( type );\n\n\t\tif ( componentType === null ) return null;\n\n\t\tif ( componentType[ 1 ] === 'b' ) return 'bool';\n\t\tif ( componentType[ 1 ] === 'i' ) return 'int';\n\t\tif ( componentType[ 1 ] === 'u' ) return 'uint';\n\n\t\treturn 'float';\n\n\t}\n\n\tgetVectorType( type ) {\n\n\t\tif ( type === 'color' ) return 'vec3';\n\t\tif ( type === 'texture' ) return 'vec4';\n\n\t\treturn type;\n\n\t}\n\n\tgetTypeFromLength( type ) {\n\n\t\tif ( type === 1 ) return 'float';\n\t\tif ( type === 2 ) return 'vec2';\n\t\tif ( type === 3 ) return 'vec3';\n\t\tif ( type === 4 ) return 'vec4';\n\n\t\treturn 0;\n\n\t}\n\n\tgetTypeLength( type ) {\n\n\t\tconst vecType = this.getVectorType( type );\n\t\tconst vecNum = /vec([2-4])/.exec( vecType );\n\n\t\tif ( vecNum !== null ) return Number( vecNum[ 1 ] );\n\t\tif ( vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint' ) return 1;\n\n\t\treturn 0;\n\n\t}\n\n\tgetVectorFromMatrix( type ) {\n\n\t\treturn type.replace( 'mat', 'vec' );\n\n\t}\n\n\tgetDataFromNode( node, shaderStage = this.shaderStage ) {\n\n\t\tlet nodeData = this.nodesData.get( node );\n\n\t\tif ( nodeData === undefined ) {\n\n\t\t\tnodeData = { vertex: {}, fragment: {} };\n\n\t\t\tthis.nodesData.set( node, nodeData );\n\n\t\t}\n\n\t\treturn shaderStage !== null ? nodeData[ shaderStage ] : nodeData;\n\n\t}\n\n\tgetUniformFromNode( node, shaderStage, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeUniform = nodeData.uniform;\n\n\t\tif ( nodeUniform === undefined ) {\n\n\t\t\tconst index = this.uniforms.index ++;\n\n\t\t\tnodeUniform = new NodeUniform( 'nodeUniform' + index, type, node );\n\n\t\t\tthis.uniforms[ shaderStage ].push( nodeUniform );\n\n\t\t\tnodeData.uniform = nodeUniform;\n\n\t\t}\n\n\t\treturn nodeUniform;\n\n\t}\n\n\tgetVarFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, shaderStage );\n\n\t\tlet nodeVar = nodeData.variable;\n\n\t\tif ( nodeVar === undefined ) {\n\n\t\t\tconst vars = this.vars[ shaderStage ];\n\t\t\tconst index = vars.length;\n\n\t\t\tnodeVar = new NodeVar( 'nodeVar' + index, type );\n\n\t\t\tvars.push( nodeVar );\n\n\t\t\tnodeData.variable = nodeVar;\n\n\t\t}\n\n\t\treturn nodeVar;\n\n\t}\n\n\tgetVaryFromNode( node, type ) {\n\n\t\tconst nodeData = this.getDataFromNode( node, null );\n\n\t\tlet nodeVary = nodeData.vary;\n\n\t\tif ( nodeVary === undefined ) {\n\n\t\t\tconst varys = this.varys;\n\t\t\tconst index = varys.length;\n\n\t\t\tnodeVary = new NodeVary( 'nodeVary' + index, type );\n\n\t\t\tvarys.push( nodeVary );\n\n\t\t\tnodeData.vary = nodeVary;\n\n\t\t}\n\n\t\treturn nodeVary;\n\n\t}\n\n\tgetCodeFromNode( node, type, shaderStage = this.shaderStage ) {\n\n\t\tconst nodeData = this.getDataFromNode( node );\n\n\t\tlet nodeCode = nodeData.code;\n\n\t\tif ( nodeCode === undefined ) {\n\n\t\t\tconst codes = this.codes[ shaderStage ];\n\t\t\tconst index = codes.length;\n\n\t\t\tnodeCode = new NodeCode( 'nodeCode' + index, type );\n\n\t\t\tcodes.push( nodeCode );\n\n\t\t\tnodeData.code = nodeCode;\n\n\t\t}\n\n\t\treturn nodeCode;\n\n\t}\n\n\taddFlowCode( code ) {\n\n\t\tthis.flow.code += code;\n\n\t}\n\n\tgetFlowData( shaderStage, node ) {\n\n\t\treturn this.flowsData.get( node );\n\n\t}\n\n\tflowNode( node ) {\n\n\t\tthis.node = node;\n\n\t\tconst output = node.getNodeType( this );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tthis.flowsData.set( node, flowData );\n\n\t\tthis.node = null;\n\n\t\treturn flowData;\n\n\t}\n\n\tflowChildNode( node, output = null ) {\n\n\t\tconst previousFlow = this.flow;\n\n\t\tconst flow = {\n\t\t\tcode: '',\n\t\t};\n\n\t\tthis.flow = flow;\n\n\t\tflow.result = node.build( this, output );\n\n\t\tthis.flow = previousFlow;\n\n\t\treturn flow;\n\n\t}\n\n\tflowNodeFromShaderStage( shaderStage, node, output = null, propertyName = null ) {\n\n\t\tconst previousShaderStage = this.shaderStage;\n\n\t\tthis.setShaderStage( shaderStage );\n\n\t\tconst flowData = this.flowChildNode( node, output );\n\n\t\tif ( propertyName !== null ) {\n\n\t\t\tflowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n\n\t\t}\n\n\t\tthis.flowCode[ shaderStage ] = this.flowCode[ shaderStage ] + flowData.code;\n\n\t\tthis.setShaderStage( previousShaderStage );\n\n\t\treturn flowData;\n\n\t}\n\n\tgetAttributes( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVarys( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetVars( shaderStage ) {\n\n\t\tlet snippet = '';\n\n\t\tconst vars = this.vars[ shaderStage ];\n\n\t\tfor ( let index = 0; index < vars.length; index ++ ) {\n\n\t\t\tconst variable = vars[ index ];\n\n\t\t\tsnippet += `${variable.type} ${variable.name}; `;\n\n\t\t}\n\n\t\treturn snippet;\n\n\t}\n\n\tgetUniforms( /*shaderStage*/ ) {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tgetCodes( shaderStage ) {\n\n\t\tconst codes = this.codes[ shaderStage ];\n\n\t\tlet code = '';\n\n\t\tfor ( const nodeCode of codes ) {\n\n\t\t\tcode += nodeCode.code + '\\n';\n\n\t\t}\n\n\t\treturn code;\n\n\t}\n\n\tgetHash() {\n\n\t\treturn this.vertexShader + this.fragmentShader;\n\n\t}\n\n\tgetShaderStage() {\n\n\t\treturn this.shaderStage;\n\n\t}\n\n\tsetShaderStage( shaderStage ) {\n\n\t\tthis.shaderStage = shaderStage;\n\n\t}\n\n\tbuildCode() {\n\n\t\tconsole.warn( 'Abstract function.' );\n\n\t}\n\n\tbuild() {\n\n\t\t// stage 1: analyze nodes to possible optimization and validation\n\n\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tnode.analyze( this );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// stage 2: pre-build vertex code used in fragment shader\n\n\t\tif ( this.context.vertex && this.context.vertex.isNode ) {\n\n\t\t\tthis.flowNodeFromShaderStage( 'vertex', this.context.vertex );\n\n\t\t}\n\n\t\t// stage 3: generate shader\n\n\t\tfor ( const shaderStage of shaderStages ) {\n\n\t\t\tthis.setShaderStage( shaderStage );\n\n\t\t\tconst flowNodes = this.flowNodes[ shaderStage ];\n\n\t\t\tfor ( const node of flowNodes ) {\n\n\t\t\t\tthis.flowNode( node, shaderStage );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setShaderStage( null );\n\n\t\t// stage 4: build code for a specific output\n\n\t\tthis.buildCode();\n\n\t\treturn this;\n\n\t}\n\n\tformat( snippet, fromType, toType ) {\n\n\t\tfromType = this.getVectorType( fromType );\n\t\ttoType = this.getVectorType( toType );\n\n\t\tif ( fromType === toType || toType === null || this.isReference( toType ) ) {\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tconst fromTypeLength = this.getTypeLength( fromType );\n\t\tconst toTypeLength = this.getTypeLength( toType );\n\n\t\tif ( fromTypeLength === 0 ) { // fromType is matrix-like\n\n\t\t\tconst vectorType = this.getVectorFromMatrix( fromType );\n\n\t\t\treturn this.format( `( ${ snippet } * ${ this.getType( vectorType ) }( 1.0 ) )`, vectorType, toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 0 ) { // toType is matrix-like\n\n\t\t\t// ignore for now\n\t\t\t//return `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t\treturn snippet;\n\n\t\t}\n\n\t\tif ( fromTypeLength === toTypeLength ) {\n\n\t\t\treturn `${ this.getType( toType ) }( ${ snippet } )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength > toTypeLength ) {\n\n\t\t\treturn this.format( `${ snippet }.${ 'xyz'.slice( 0, toTypeLength ) }`, this.getTypeFromLength( toTypeLength ), toType );\n\n\t\t}\n\n\t\tif ( toTypeLength === 4 ) { // toType is vec4-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec3' ) }, 1.0 )`;\n\n\t\t}\n\n\t\tif ( fromTypeLength === 2 ) { // fromType is vec2-like and toType is vec3-like\n\n\t\t\treturn `${ this.getType( toType ) }( ${ this.format( snippet, fromType, 'vec2' ) }, 0.0 )`;\n\n\t\t}\n\n\t\treturn `${ this.getType( toType ) }( ${ snippet } )`; // fromType is float-like\n\n\t}\n\n\tgetSignature() {\n\n\t\treturn `// Three.js r${ REVISION } - NodeMaterial System\\n`;\n\n\t}\n\n}\n\nexport default NodeBuilder;\n", "import Node from '../core/Node.js';\nimport { vector } from '../core/NodeBuilder.js';\n\nclass SplitNode extends Node {\n\n\tconstructor( node, components = 'x' ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.components = components;\n\n\t}\n\n\tgetVectorLength() {\n\n\t\tlet vectorLength = this.components.length;\n\n\t\tfor ( const c of this.components ) {\n\n\t\t\tvectorLength = Math.max( vector.indexOf( c ) + 1, vectorLength );\n\n\t\t}\n\n\t\treturn vectorLength;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn builder.getTypeFromLength( this.components.length );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst node = this.node;\n\t\tconst nodeTypeLength = builder.getTypeLength( node.getNodeType( builder ) );\n\n\t\tif ( nodeTypeLength > 1 ) {\n\n\t\t\tlet type = null;\n\n\t\t\tconst componentsLength = this.getVectorLength();\n\n\t\t\tif ( componentsLength >= nodeTypeLength ) {\n\n\t\t\t\t// need expand the input node\n\n\t\t\t\ttype = builder.getTypeFromLength( this.getVectorLength() );\n\n\t\t\t}\n\n\t\t\tconst nodeSnippet = node.build( builder, type );\n\n\t\t\treturn `${nodeSnippet}.${this.components}`;\n\n\t\t} else {\n\n\t\t\t// ignore components if node is a float\n\n\t\t\treturn node.build( builder );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.components = this.components;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.components = data.components;\n\n\t}\n\n}\n\nexport default SplitNode;\n", "import TempNode from '../core/TempNode.js';\n\nclass OperatorNode extends TempNode {\n\n\tconstructor( op, aNode, bNode, ...params ) {\n\n\t\tsuper();\n\n\t\tthis.op = op;\n\n\t\tif ( params.length > 0 ) {\n\n\t\t\tlet finalBNode = bNode;\n\n\t\t\tfor ( let i = 0; i < params.length; i ++ ) {\n\n\t\t\t\tfinalBNode = new OperatorNode( op, finalBNode, params[ i ] );\n\n\t\t\t}\n\n\t\t\tbNode = finalBNode;\n\n\t\t}\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\n\t}\n\n\tgetNodeType( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst typeA = aNode.getNodeType( builder );\n\t\tconst typeB = bNode.getNodeType( builder );\n\n\t\tif ( typeA === 'void' || typeB === 'void' ) {\n\n\t\t\treturn 'void';\n\n\t\t} else if ( op === '=' || op === '%' ) {\n\n\t\t\treturn typeA;\n\n\t\t} else if ( op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<' ) {\n\n\t\t\treturn 'int';\n\n\t\t} else if ( op === '==' || op === '&&' || op === '||' || op === '^^' ) {\n\n\t\t\treturn 'bool';\n\n\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\tconst typeLength = builder.getTypeLength( output );\n\n\t\t\treturn typeLength > 1 ? `bvec${ typeLength }` : 'bool';\n\n\t\t} else {\n\n\t\t\tif ( typeA === 'float' && builder.isMatrix( typeB ) ) {\n\n\t\t\t\treturn typeB;\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\treturn builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else if ( builder.getTypeLength( typeB ) > builder.getTypeLength( typeA ) ) {\n\n\t\t\t\t// anytype x anytype: use the greater length vector\n\n\t\t\t\treturn typeB;\n\n\t\t\t}\n\n\t\t\treturn typeA;\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst op = this.op;\n\n\t\tconst aNode = this.aNode;\n\t\tconst bNode = this.bNode;\n\n\t\tconst type = this.getNodeType( builder, output );\n\n\t\tlet typeA = null;\n\t\tlet typeB = null;\n\n\t\tif ( type !== 'void' ) {\n\n\t\t\ttypeA = aNode.getNodeType( builder );\n\t\t\ttypeB = bNode.getNodeType( builder );\n\n\t\t\tif ( op === '=' ) {\n\n\t\t\t\ttypeB = typeA;\n\n\t\t\t} else if ( op === '<' || op === '>' || op === '<=' || op === '>=' ) {\n\n\t\t\t\tif ( builder.isVector( typeA ) ) {\n\n\t\t\t\t\ttypeB = typeA;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttypeA = typeB = 'float';\n\n\t\t\t\t}\n\n\t\t\t} else if ( builder.isMatrix( typeA ) && builder.isVector( typeB ) ) {\n\n\t\t\t\t// matrix x vector\n\n\t\t\t\ttypeB = builder.getVectorFromMatrix( typeA );\n\n\t\t\t} else if ( builder.isVector( typeA ) && builder.isMatrix( typeB ) ) {\n\n\t\t\t\t// vector x matrix\n\n\t\t\t\ttypeA = builder.getVectorFromMatrix( typeB );\n\n\t\t\t} else {\n\n\t\t\t\t// anytype x anytype\n\n\t\t\t\ttypeA = typeB = type;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttypeA = typeB = type;\n\n\t\t}\n\n\t\tconst a = aNode.build( builder, typeA );\n\t\tconst b = bNode.build( builder, typeB );\n\n\t\tconst outputLength = builder.getTypeLength( output );\n\n\t\tif ( output !== 'void' ) {\n\n\t\t\tif ( op === '=' ) {\n\n\t\t\t\tbuilder.addFlowCode( `${a} ${this.op} ${b}` );\n\n\t\t\t\treturn a;\n\n\t\t\t} else if ( op === '>' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'greaterThan' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else if ( op === '<=' && outputLength > 1 ) {\n\n\t\t\t\treturn builder.format( `${ builder.getMethod( 'lessThanEqual' ) }( ${a}, ${b} )`, type, output );\n\n\t\t\t} else {\n\n\t\t\t\treturn builder.format( `( ${a} ${this.op} ${b} )`, type, output );\n\n\t\t\t}\n\n\t\t} else if ( typeA !== 'void' ) {\n\n\t\t\treturn builder.format( `${a} ${this.op} ${b}`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.op = this.op;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.op = data.op;\n\n\t}\n\n}\n\nexport default OperatorNode;\n", "import TempNode from '../core/TempNode.js';\nimport ExpressionNode from '../core/ExpressionNode.js';\nimport JoinNode from '../utils/JoinNode.js';\nimport SplitNode from '../utils/SplitNode.js';\nimport OperatorNode from './OperatorNode.js';\n\nclass MathNode extends TempNode {\n\n\t// 1 input\n\n\tstatic RAD = 'radians';\n\tstatic DEG = 'degrees';\n\tstatic EXP = 'exp';\n\tstatic EXP2 = 'exp2';\n\tstatic LOG = 'log';\n\tstatic LOG2 = 'log2';\n\tstatic SQRT = 'sqrt';\n\tstatic INV_SQRT = 'inversesqrt';\n\tstatic FLOOR = 'floor';\n\tstatic CEIL = 'ceil';\n\tstatic NORMALIZE = 'normalize';\n\tstatic FRACT = 'fract';\n\tstatic SIN = 'sin';\n\tstatic COS = 'cos';\n\tstatic TAN = 'tan';\n\tstatic ASIN = 'asin';\n\tstatic ACOS = 'acos';\n\tstatic ATAN = 'atan';\n\tstatic ABS = 'abs';\n\tstatic SIGN = 'sign';\n\tstatic LENGTH = 'length';\n\tstatic NEGATE = 'negate';\n\tstatic INVERT = 'invert';\n\tstatic DFDX = 'dFdx';\n\tstatic DFDY = 'dFdy';\n\tstatic SATURATE = 'saturate';\n\tstatic ROUND = 'round';\n\n\t// 2 inputs\n\n\tstatic MIN = 'min';\n\tstatic MAX = 'max';\n\tstatic MOD = 'mod';\n\tstatic STEP = 'step';\n\tstatic REFLECT = 'reflect';\n\tstatic DISTANCE = 'distance';\n\tstatic DOT = 'dot';\n\tstatic CROSS = 'cross';\n\tstatic POW = 'pow';\n\tstatic TRANSFORM_DIRECTION = 'transformDirection';\n\n\t// 3 inputs\n\n\tstatic MIX = 'mix';\n\tstatic CLAMP = 'clamp';\n\tstatic REFRACT = 'refract';\n\tstatic SMOOTHSTEP = 'smoothstep';\n\tstatic FACEFORWARD = 'faceforward';\n\n\tconstructor( method, aNode, bNode = null, cNode = null ) {\n\n\t\tsuper();\n\n\t\tthis.method = method;\n\n\t\tthis.aNode = aNode;\n\t\tthis.bNode = bNode;\n\t\tthis.cNode = cNode;\n\n\t}\n\n\tgetInputType( builder ) {\n\n\t\tconst aType = this.aNode.getNodeType( builder );\n\t\tconst bType = this.bNode ? this.bNode.getNodeType( builder ) : null;\n\t\tconst cType = this.cNode ? this.cNode.getNodeType( builder ) : null;\n\n\t\tconst aLen = builder.getTypeLength( aType );\n\t\tconst bLen = builder.getTypeLength( bType );\n\t\tconst cLen = builder.getTypeLength( cType );\n\n\t\tif ( aLen > bLen && aLen > cLen ) {\n\n\t\t\treturn aType;\n\n\t\t} else if ( bLen > cLen ) {\n\n\t\t\treturn bType;\n\n\t\t} else if ( cLen > aLen ) {\n\n\t\t\treturn cType;\n\n\t\t}\n\n\t\treturn aType;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst method = this.method;\n\n\t\tif ( method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT ) {\n\n\t\t\treturn 'float';\n\n\t\t} else if ( method === MathNode.CROSS ) {\n\n\t\t\treturn 'vec3';\n\n\t\t} else {\n\n\t\t\treturn this.getInputType( builder );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst method = this.method;\n\n\t\tconst type = this.getNodeType( builder );\n\t\tconst inputType = this.getInputType( builder );\n\n\t\tconst a = this.aNode;\n\t\tconst b = this.bNode;\n\t\tconst c = this.cNode;\n\n\t\tconst isWebGL = builder.renderer.isWebGLRenderer === true;\n\n\t\tif ( isWebGL && ( method === MathNode.DFDX || method === MathNode.DFDY ) && output === 'vec3' ) {\n\n\t\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\t\treturn new JoinNode( [\n\t\t\t\tnew MathNode( method, new SplitNode( a, 'x' ) ),\n\t\t\t\tnew MathNode( method, new SplitNode( a, 'y' ) ),\n\t\t\t\tnew MathNode( method, new SplitNode( a, 'z' ) )\n\t\t\t] ).build( builder );\n\n\t\t} else if ( method === MathNode.TRANSFORM_DIRECTION ) {\n\n\t\t\t// dir can be either a direction vector or a normal vector\n\t\t\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\t\t\tlet tA = a;\n\t\t\tlet tB = b;\n\n\t\t\tif ( builder.isMatrix( tA.getNodeType( builder ) ) ) {\n\n\t\t\t\ttB = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tB.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\n\n\t\t\t} else {\n\n\t\t\t\ttA = new ExpressionNode( `${ builder.getType( 'vec4' ) }( ${ tA.build( builder, 'vec3' ) }, 0.0 )`, 'vec4' );\n\n\t\t\t}\n\n\t\t\tconst mulNode = new SplitNode( new OperatorNode( '*', tA, tB ), 'xyz' );\n\n\t\t\treturn new MathNode( MathNode.NORMALIZE, mulNode ).build( builder );\n\n\t\t} else if ( method === MathNode.SATURATE ) {\n\n\t\t\treturn builder.format( `clamp( ${ a.build( builder, inputType ) }, 0.0, 1.0 )`, type, output );\n\n\t\t} else if ( method === MathNode.NEGATE ) {\n\n\t\t\treturn builder.format( '( -' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else if ( method === MathNode.INVERT ) {\n\n\t\t\treturn builder.format( '( 1.0 - ' + a.build( builder, inputType ) + ' )', type, output );\n\n\t\t} else {\n\n\t\t\tconst params = [];\n\n\t\t\tif ( method === MathNode.CROSS ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, type ),\n\t\t\t\t\tb.build( builder, type )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.STEP ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, builder.getTypeLength( a.getNodeType( builder ) ) === 1 ? 'float' : inputType ),\n\t\t\t\t\tb.build( builder, inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( ( isWebGL && ( method === MathNode.MIN || method === MathNode.MAX ) ) || method === MathNode.MOD ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, builder.getTypeLength( b.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.REFRACT ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, 'float' )\n\t\t\t\t);\n\n\t\t\t} else if ( method === MathNode.MIX ) {\n\n\t\t\t\tparams.push(\n\t\t\t\t\ta.build( builder, inputType ),\n\t\t\t\t\tb.build( builder, inputType ),\n\t\t\t\t\tc.build( builder, builder.getTypeLength( c.getNodeType( builder ) ) === 1 ? 'float' : inputType )\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tparams.push( a.build( builder, inputType ) );\n\n\t\t\t\tif ( c !== null ) {\n\n\t\t\t\t\tparams.push( b.build( builder, inputType ), c.build( builder, inputType ) );\n\n\t\t\t\t} else if ( b !== null ) {\n\n\t\t\t\t\tparams.push( b.build( builder, inputType ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn builder.format( `${ builder.getMethod( method ) }( ${params.join( ', ' )} )`, type, output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.method = this.method;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.method = data.method;\n\n\t}\n\n}\n\nexport default MathNode;\n", "import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryNode from '../core/VaryNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport MathNode from '../math/MathNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\n\nclass PositionNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic WORLD = 'world';\n\tstatic VIEW = 'view';\n\tstatic VIEW_DIRECTION = 'viewDirection';\n\n\tconstructor( scope = PositionNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `position-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === PositionNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'position', 'vec3' );\n\n\t\t} else if ( scope === PositionNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryNode( new PositionNode( PositionNode.GEOMETRY ) );\n\n\t\t} else if ( scope === PositionNode.WORLD ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new ModelNode( ModelNode.WORLD_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW ) {\n\n\t\t\tconst vertexPositionNode = new OperatorNode( '*', new ModelNode( ModelNode.VIEW_MATRIX ), new PositionNode( PositionNode.LOCAL ) );\n\t\t\toutputNode = new VaryNode( vertexPositionNode );\n\n\t\t} else if ( scope === PositionNode.VIEW_DIRECTION ) {\n\n\t\t\tconst vertexPositionNode = new MathNode( MathNode.NEGATE, new PositionNode( PositionNode.VIEW ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryNode( vertexPositionNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder, this.getNodeType( builder ) );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default PositionNode;\n", "import Object3DNode from './Object3DNode.js';\n\nclass CameraNode extends Object3DNode {\n\n\tstatic PROJECTION_MATRIX = 'projectionMatrix';\n\n\tconstructor( scope = CameraNode.POSITION ) {\n\n\t\tsuper( scope );\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\treturn 'mat4';\n\n\t\t}\n\n\t\treturn super.getNodeType( builder );\n\n\t}\n\n\tupdate( frame ) {\n\n\t\tconst camera = frame.camera;\n\t\tconst uniformNode = this._uniformNode;\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\tuniformNode.value = camera.projectionMatrix;\n\n\t\t} else if ( scope === CameraNode.VIEW_MATRIX ) {\n\n\t\t\tuniformNode.value = camera.matrixWorldInverse;\n\n\t\t} else {\n\n\t\t\tthis.object3d = camera;\n\n\t\t\tsuper.update( frame );\n\n\t\t}\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tif ( scope === CameraNode.PROJECTION_MATRIX ) {\n\n\t\t\tthis._uniformNode.nodeType = 'mat4';\n\n\t\t}\n\n\t\treturn super.generate( builder );\n\n\t}\n\n}\n\nexport default CameraNode;\n", "import Node from '../core/Node.js';\nimport AttributeNode from '../core/AttributeNode.js';\nimport VaryNode from '../core/VaryNode.js';\nimport ModelNode from '../accessors/ModelNode.js';\nimport CameraNode from '../accessors/CameraNode.js';\nimport OperatorNode from '../math/OperatorNode.js';\nimport MathNode from '../math/MathNode.js';\n\nclass NormalNode extends Node {\n\n\tstatic GEOMETRY = 'geometry';\n\tstatic LOCAL = 'local';\n\tstatic WORLD = 'world';\n\tstatic VIEW = 'view';\n\n\tconstructor( scope = NormalNode.LOCAL ) {\n\n\t\tsuper( 'vec3' );\n\n\t\tthis.scope = scope;\n\n\t}\n\n\tgetHash( /*builder*/ ) {\n\n\t\treturn `normal-${this.scope}`;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst scope = this.scope;\n\n\t\tlet outputNode = null;\n\n\t\tif ( scope === NormalNode.GEOMETRY ) {\n\n\t\t\toutputNode = new AttributeNode( 'normal', 'vec3' );\n\n\t\t} else if ( scope === NormalNode.LOCAL ) {\n\n\t\t\toutputNode = new VaryNode( new NormalNode( NormalNode.GEOMETRY ) );\n\n\t\t} else if ( scope === NormalNode.VIEW ) {\n\n\t\t\tconst vertexNormalNode = new OperatorNode( '*', new ModelNode( ModelNode.NORMAL_MATRIX ), new NormalNode( NormalNode.LOCAL ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryNode( vertexNormalNode ) );\n\n\t\t} else if ( scope === NormalNode.WORLD ) {\n\n\t\t\t// To use INVERSE_TRANSFORM_DIRECTION only inverse the param order like this: MathNode( ..., Vector, Matrix );\n\t\t\tconst vertexNormalNode = new MathNode( MathNode.TRANSFORM_DIRECTION, new NormalNode( NormalNode.VIEW ), new CameraNode( CameraNode.VIEW_MATRIX ) );\n\t\t\toutputNode = new MathNode( MathNode.NORMALIZE, new VaryNode( vertexNormalNode ) );\n\n\t\t}\n\n\t\treturn outputNode.build( builder );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.scope = this.scope;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.scope = data.scope;\n\n\t}\n\n}\n\nexport default NormalNode;\n", "import AttributeNode from '../core/AttributeNode.js';\n\nclass UVNode extends AttributeNode {\n\n\tconstructor( index = 0 ) {\n\n\t\tsuper( null, 'vec2' );\n\n\t\tthis.index = index;\n\n\t}\n\n\tgetAttributeName( /*builder*/ ) {\n\n\t\tconst index = this.index;\n\n\t\treturn 'uv' + ( index > 0 ? index + 1 : '' );\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.index = this.index;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.index = data.index;\n\n\t}\n\n}\n\nUVNode.prototype.isUVNode = true;\n\nexport default UVNode;\n", "import UniformNode from '../core/UniformNode.js';\nimport UVNode from './UVNode.js';\n\nclass TextureNode extends UniformNode {\n\n\tconstructor( value, uvNode = new UVNode(), biasNode = null ) {\n\n\t\tsuper( value, 'vec4' );\n\n\t\tthis.uvNode = uvNode;\n\t\tthis.biasNode = biasNode;\n\n\t}\n\n\tgetUniformHash( /*builder*/ ) {\n\n\t\treturn this.value.uuid;\n\n\t}\n\n\tgetInputType( /*builder*/ ) {\n\n\t\treturn 'texture';\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst texture = this.value;\n\n\t\tif ( ! texture || texture.isTexture !== true ) {\n\n\t\t\tthrow new Error( 'TextureNode: Need a three.js texture.' );\n\n\t\t}\n\n\t\tconst textureProperty = super.generate( builder, 'texture' );\n\n\t\tif ( output === 'sampler' ) {\n\n\t\t\treturn textureProperty + '_sampler';\n\n\t\t} else if ( builder.isReference( output ) ) {\n\n\t\t\treturn textureProperty;\n\n\t\t} else {\n\n\t\t\tconst nodeData = builder.getDataFromNode( this );\n\n\t\t\tlet snippet = nodeData.snippet;\n\n\t\t\tif ( snippet === undefined ) {\n\n\t\t\t\tconst uvSnippet = this.uvNode.build( builder, 'vec2' );\n\t\t\t\tconst biasNode = this.biasNode;\n\n\t\t\t\tif ( biasNode !== null ) {\n\n\t\t\t\t\tconst biasSnippet = biasNode.build( builder, 'float' );\n\n\t\t\t\t\tsnippet = builder.getTextureBias( textureProperty, uvSnippet, biasSnippet );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsnippet = builder.getTexture( textureProperty, uvSnippet );\n\n\t\t\t\t}\n\n\t\t\t\tnodeData.snippet = snippet;\n\n\t\t\t}\n\n\t\t\treturn builder.format( snippet, 'vec4', output );\n\n\t\t}\n\n\t}\n\n\tserialize( data ) {\n\n\t\tsuper.serialize( data );\n\n\t\tdata.value = this.value.toJSON( data.meta ).uuid;\n\n\t}\n\n\tdeserialize( data ) {\n\n\t\tsuper.deserialize( data );\n\n\t\tthis.value = data.meta.textures[ data.value ];\n\n\t}\n\n}\n\nTextureNode.prototype.isTextureNode = true;\n\nexport default TextureNode;\n", "import Node from './Node.js';\n\nclass ContextNode extends Node {\n\n\tconstructor( node, context = {} ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.context = context;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder, output ) {\n\n\t\tconst previousContext = builder.getContext();\n\n\t\tbuilder.setContext( Object.assign( {}, builder.context, this.context ) );\n\n\t\tconst snippet = this.node.build( builder, output );\n\n\t\tbuilder.setContext( previousContext );\n\n\t\treturn snippet;\n\n\t}\n\n}\n\nContextNode.prototype.isContextNode = true;\n\nexport default ContextNode;\n", "import Node from '../core/Node.js';\nimport PropertyNode from '../core/PropertyNode.js';\nimport ContextNode from '../core/ContextNode.js';\n\nclass CondNode extends Node {\n\n\tconstructor( node, ifNode, elseNode ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\n\t\tthis.ifNode = ifNode;\n\t\tthis.elseNode = elseNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\tconst ifType = this.ifNode.getNodeType( builder );\n\t\tconst elseType = this.elseNode.getNodeType( builder );\n\n\t\tif ( builder.getTypeLength( elseType ) > builder.getTypeLength( ifType ) ) {\n\n\t\t\treturn elseType;\n\n\t\t}\n\n\t\treturn ifType;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst type = this.getNodeType( builder );\n\n\t\tconst context = { temp: false };\n\t\tconst nodeProperty = new PropertyNode( null, type ).build( builder );\n\n\t\tconst nodeSnippet = new ContextNode( this.node/*, context*/ ).build( builder, 'bool' ),\n\t\t\tifSnippet = new ContextNode( this.ifNode, context ).build( builder, type ),\n\t\t\telseSnippet = new ContextNode( this.elseNode, context ).build( builder, type );\n\n\t\tbuilder.addFlowCode( `if ( ${nodeSnippet} ) {\n\n\\t\\t${nodeProperty} = ${ifSnippet};\n\n\\t} else {\n\n\\t\\t${nodeProperty} = ${elseSnippet};\n\n\\t}` );\n\n\t\treturn nodeProperty;\n\n\t}\n\n}\n\nexport default CondNode;\n", "import Node from '../core/Node.js';\n\nclass ArrayElementNode extends Node {\n\n\tconstructor( node, indexNode ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.indexNode = indexNode;\n\n\t}\n\n\tgetNodeType( builder ) {\n\n\t\treturn this.node.getNodeType( builder );\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst nodeSnippet = this.node.build( builder );\n\t\tconst indexSnippet = this.indexNode.build( builder, 'int' );\n\n\t\treturn `${nodeSnippet}[ ${indexSnippet} ]`;\n\n\t}\n\n}\n\nexport default ArrayElementNode;\n", "import Node from '../core/Node.js';\n\nclass ConvertNode extends Node {\n\n\tconstructor( node, convertTo ) {\n\n\t\tsuper();\n\n\t\tthis.node = node;\n\t\tthis.convertTo = convertTo;\n\n\t}\n\n\tgetNodeType( /*builder*/ ) {\n\n\t\treturn this.convertTo;\n\n\t}\n\n\tgenerate( builder ) {\n\n\t\tconst convertTo = this.convertTo;\n\t\tconst node = this.node;\n\n\t\tif ( builder.isReference( convertTo ) === false ) {\n\n\t\t\tconst convertToSnippet = builder.getType( convertTo );\n\t\t\tconst nodeSnippet = node.build( builder, convertTo );\n\n\t\t\treturn `${ builder.getVectorType( convertToSnippet ) }( ${ nodeSnippet } )`;\n\n\t\t} else {\n\n\t\t\treturn node.build( builder, convertTo );\n\n\t\t}\n\n\t}\n\n}\n\nexport default ConvertNode;\n", "// core nodes\nimport PropertyNode from './core/PropertyNode.js';\nimport VarNode from './core/VarNode.js';\nimport AttributeNode from './core/AttributeNode.js';\nimport ConstNode from './core/ConstNode.js';\nimport UniformNode from './core/UniformNode.js';\n\n// accessor nodes\nimport BufferNode from './accessors/BufferNode.js';\nimport PositionNode from './accessors/PositionNode.js';\nimport NormalNode from './accessors/NormalNode.js';\nimport CameraNode from './accessors/CameraNode.js';\nimport ModelNode from './accessors/ModelNode.js';\nimport TextureNode from './accessors/TextureNode.js';\nimport UVNode from './accessors/UVNode.js';\n\n// math nodes\nimport OperatorNode from './math/OperatorNode.js';\nimport CondNode from './math/CondNode.js';\nimport MathNode from './math/MathNode.js';\n\n// util nodes\nimport ArrayElementNode from './utils/ArrayElementNode.js';\nimport ConvertNode from './utils/ConvertNode.js';\nimport JoinNode from './utils/JoinNode.js';\nimport SplitNode from './utils/SplitNode.js';\n\n// utils\nimport { getValueFromType } from './core/NodeUtils.js';\n\nconst NodeHandler = {\n\n\tconstruct( NodeClosure, params ) {\n\n\t\tconst inputs = params.shift();\n\n\t\treturn NodeClosure( new ShaderNodeObjects( inputs ), ...params );\n\n\t},\n\n\tget: function ( node, prop ) {\n\n\t\tif ( typeof prop === 'string' && node[ prop ] === undefined ) {\n\n\t\t\tif ( /^[xyzwrgbastpq]{1,4}$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing properties ( swizzle )\n\n\t\t\t\tprop = prop\n\t\t\t\t\t.replace( /r|s/g, 'x' )\n\t\t\t\t\t.replace( /g|t/g, 'y' )\n\t\t\t\t\t.replace( /b|p/g, 'z' )\n\t\t\t\t\t.replace( /a|q/g, 'w' );\n\n\t\t\t\treturn new ShaderNodeObject( new SplitNode( node, prop ) );\n\n\t\t\t} else if ( /^\\d+$/.test( prop ) === true ) {\n\n\t\t\t\t// accessing array\n\n\t\t\t\treturn new ShaderNodeObject( new ArrayElementNode( node, uint( Number( prop ) ) ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn node[ prop ];\n\n\t}\n\n};\n\nconst nodeObjects = new WeakMap();\n\nconst ShaderNodeObject = function ( obj ) {\n\n\tconst type = typeof obj;\n\n\tif ( ( type === 'number' ) || ( type === 'boolean' ) ) {\n\n\t\treturn new ShaderNodeObject( getAutoTypedConstNode( obj ) );\n\n\t} else if ( type === 'object' ) {\n\n\t\tif ( obj.isNode === true ) {\n\n\t\t\tlet nodeObject = nodeObjects.get( obj );\n\n\t\t\tif ( nodeObject === undefined ) {\n\n\t\t\t\tnodeObject = new Proxy( obj, NodeHandler );\n\t\t\t\tnodeObjects.set( obj, nodeObject );\n\t\t\t\tnodeObjects.set( nodeObject, nodeObject );\n\n\t\t\t}\n\n\t\t\treturn nodeObject;\n\n\t\t}\n\n\t}\n\n\treturn obj;\n\n};\n\nconst ShaderNodeObjects = function ( objects ) {\n\n\tfor ( const name in objects ) {\n\n\t\tobjects[ name ] = new ShaderNodeObject( objects[ name ] );\n\n\t}\n\n\treturn objects;\n\n};\n\nconst getShaderNodeArray = ( array ) => {\n\n\tconst len = array.length;\n\n\tfor ( let i = 0; i < len; i ++ ) {\n\n\t\tarray[ i ] = new ShaderNodeObject( array[ i ] );\n\n\t}\n\n\treturn array;\n\n};\n\nconst ShaderNodeProxy = function ( NodeClass, scope = null, factor = null ) {\n\n\tif ( scope === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn new ShaderNodeObject( new NodeClass( ...getShaderNodeArray( params ) ) );\n\n\t\t};\n\n\t} else if ( factor === null ) {\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn new ShaderNodeObject( new NodeClass( scope, ...getShaderNodeArray( params ) ) );\n\n\t\t};\n\n\t} else {\n\n\t\tfactor = new ShaderNodeObject( factor );\n\n\t\treturn ( ...params ) => {\n\n\t\t\treturn new ShaderNodeObject( new NodeClass( scope, ...getShaderNodeArray( params ), factor ) );\n\n\t\t};\n\n\t}\n\n};\n\nconst ShaderNodeScript = function ( jsFunc ) {\n\n\treturn ( inputs, builder ) => {\n\n\t\tnew ShaderNodeObjects( inputs );\n\n\t\treturn new ShaderNodeObject( jsFunc( inputs, builder ) );\n\n\t};\n\n};\n\nconst bools = [ false, true ];\nconst uints = [ 0, 1, 2, 3 ];\nconst ints = [ -1, -2 ];\nconst floats = [ 0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / ( Math.PI * 2), Math.PI / 2 ];\n\nconst boolsCacheMap = new Map();\nfor ( let bool of bools ) boolsCacheMap.set( bool, new ConstNode( bool ) );\n\nconst uintsCacheMap = new Map();\nfor ( let uint of uints ) uintsCacheMap.set( uint, new ConstNode( uint, 'uint' ) );\n\nconst intsCacheMap = new Map( [ ...uintsCacheMap ].map( el => new ConstNode( el.value, 'int' ) ) );\nfor ( let int of ints ) intsCacheMap.set( int, new ConstNode( int, 'int' ) );\n\nconst floatsCacheMap = new Map( [ ...intsCacheMap ].map( el => new ConstNode( el.value ) ) );\nfor ( let float of floats ) floatsCacheMap.set( float, new ConstNode( float ) );\nfor ( let float of floats ) floatsCacheMap.set( - float, new ConstNode( - float ) );\n\nconst constNodesCacheMap = new Map( [ ...boolsCacheMap, ...floatsCacheMap ] );\n\nconst getAutoTypedConstNode = ( value ) => {\n\n\tif ( constNodesCacheMap.has( value ) ) {\n\n\t\treturn constNodesCacheMap.get( value );\n\n\t} else if ( value.isNode === true ) {\n\n\t\treturn value;\n\n\t} else {\n\n\t\treturn new ConstNode( value );\n\n\t}\n\n};\n\nconst ConvertType = function ( type, cacheMap = null ) {\n\n\treturn ( ...params ) => {\n\n\t\tif ( params.length === 0 ) {\n\n\t\t\treturn nodeObject( new ConstNode( getValueFromType( type ), type ) );\n\n\t\t} else {\n\n\t\t\tif ( type === 'color' && params[ 0 ].isNode !== true ) {\n\n\t\t\t\tparams = [ getValueFromType( type, ...params ) ];\n\n\t\t\t}\n\n\t\t\tif ( params.length === 1 && cacheMap !== null && cacheMap.has( params[ 0 ] ) ) {\n\n\t\t\t\treturn cacheMap.get( params[ 0 ] );\n\n\t\t\t}\n\n\t\t\tconst nodes = params.map( getAutoTypedConstNode );\n\n\t\t\treturn nodeObject( new ConvertNode( nodes.length === 1 ? nodes[ 0 ] : new JoinNode( nodes ), type ) );\n\n\t\t}\n\n\t};\n\n};\n\n//\n// Node Material Shader Syntax\n//\n\nexport const ShaderNode = new Proxy( ShaderNodeScript, NodeHandler );\n\nexport const nodeObject = ( val ) => {\n\n\treturn new ShaderNodeObject( val );\n\n};\n\nexport const uniform = ( value ) => {\n\n\t// TODO: get ConstNode from .traverse() in the future\n\tvalue = value.isNode === true ? value.node?.value || value.value : value;\n\n\treturn nodeObject( new UniformNode( value, value.nodeType ) );\n\n};\n\nexport const label = ( node, name ) => {\n\n\tnode = nodeObject( node );\n\n\tif ( node.isVarNode === true ) {\n\n\t\tnode.name = name;\n\n\t\treturn node;\n\n\t}\n\n\treturn nodeObject( new VarNode( node, name ) );\n\n};\n\nexport const temp = ( node ) => nodeObject( new VarNode( nodeObject( node ) ) );\n\nexport const color = new ConvertType( 'color' );\n\nexport const float = new ConvertType( 'float', floatsCacheMap );\nexport const int = new ConvertType( 'int', intsCacheMap );\nexport const uint = new ConvertType( 'uint', uintsCacheMap );\nexport const bool = new ConvertType( 'bool', boolsCacheMap );\n\nexport const vec2 = new ConvertType( 'vec2' );\nexport const ivec2 = new ConvertType( 'ivec2' );\nexport const uvec2 = new ConvertType( 'uvec2' );\nexport const bvec2 = new ConvertType( 'bvec2' );\n\nexport const vec3 = new ConvertType( 'vec3' );\nexport const ivec3 = new ConvertType( 'ivec3' );\nexport const uvec3 = new ConvertType( 'uvec3' );\nexport const bvec3 = new ConvertType( 'bvec3' );\n\nexport const vec4 = new ConvertType( 'vec4' );\nexport const ivec4 = new ConvertType( 'ivec4' );\nexport const uvec4 = new ConvertType( 'uvec4' );\nexport const bvec4 = new ConvertType( 'bvec4' );\n\nexport const mat3 = new ConvertType( 'mat3' );\nexport const imat3 = new ConvertType( 'imat3' );\nexport const umat3 = new ConvertType( 'umat3' );\nexport const bmat3 = new ConvertType( 'bmat3' );\n\nexport const mat4 = new ConvertType( 'mat4' );\nexport const imat4 = new ConvertType( 'imat4' );\nexport const umat4 = new ConvertType( 'umat4' );\nexport const bmat4 = new ConvertType( 'bmat4' );\n\nexport const join = ( ...params ) => nodeObject( new JoinNode( getShaderNodeArray( params ) ) );\n\nexport const uv = ( ...params ) => nodeObject( new UVNode( ...params ) );\nexport const attribute = ( ...params ) => nodeObject( new AttributeNode( ...params ) );\nexport const buffer = ( ...params ) => nodeObject( new BufferNode( ...params ) );\nexport const texture = ( ...params ) => nodeObject( new TextureNode( ...params ) );\nexport const sampler = ( texture ) => nodeObject( new ConvertNode( texture.isNode === true ? texture : new TextureNode( texture ), 'sampler' ) );\n\nexport const cond = ( ...params ) => nodeObject( new CondNode( ...getShaderNodeArray( params ) ) );\n\nexport const addTo = ( varNode, ...params ) => {\n\n\tvarNode.node = add( varNode.node, ...getShaderNodeArray( params ) );\n\n\treturn nodeObject( varNode );\n\n};\n\nexport const add = new ShaderNodeProxy( OperatorNode, '+' );\nexport const sub = new ShaderNodeProxy( OperatorNode, '-' );\nexport const mul = new ShaderNodeProxy( OperatorNode, '*' );\nexport const div = new ShaderNodeProxy( OperatorNode, '/' );\nexport const remainder = new ShaderNodeProxy( OperatorNode, '%' );\nexport const equal = new ShaderNodeProxy( OperatorNode, '==' );\nexport const assign = new ShaderNodeProxy( OperatorNode, '=' );\nexport const lessThan = new ShaderNodeProxy( OperatorNode, '<' );\nexport const greaterThan = new ShaderNodeProxy( OperatorNode, '>' );\nexport const lessThanEqual = new ShaderNodeProxy( OperatorNode, '<=' );\nexport const greaterThanEqual = new ShaderNodeProxy( OperatorNode, '>=' );\nexport const and = new ShaderNodeProxy( OperatorNode, '&&' );\nexport const or = new ShaderNodeProxy( OperatorNode, '||' );\nexport const xor = new ShaderNodeProxy( OperatorNode, '^^' );\nexport const bitAnd = new ShaderNodeProxy( OperatorNode, '&' );\nexport const bitOr = new ShaderNodeProxy( OperatorNode, '|' );\nexport const bitXor = new ShaderNodeProxy( OperatorNode, '^' );\nexport const shiftLeft = new ShaderNodeProxy( OperatorNode, '<<' );\nexport const shiftRight = new ShaderNodeProxy( OperatorNode, '>>' );\n\nexport const element = new ShaderNodeProxy( ArrayElementNode );\n\nexport const normalGeometry = new ShaderNodeObject( new NormalNode( NormalNode.GEOMETRY ) );\nexport const normalLocal = new ShaderNodeObject( new NormalNode( NormalNode.LOCAL ) );\nexport const normalWorld = new ShaderNodeObject( new NormalNode( NormalNode.WORLD ) );\nexport const normalView = new ShaderNodeObject( new NormalNode( NormalNode.VIEW ) );\nexport const transformedNormalView = new ShaderNodeObject( new VarNode( new NormalNode( NormalNode.VIEW ), 'TransformedNormalView', 'vec3' ) );\n\nexport const positionLocal = new ShaderNodeObject( new PositionNode( PositionNode.LOCAL ) );\nexport const positionWorld = new ShaderNodeObject( new PositionNode( PositionNode.WORLD ) );\nexport const positionView = new ShaderNodeObject( new PositionNode( PositionNode.VIEW ) );\nexport const positionViewDirection = new ShaderNodeObject( new PositionNode( PositionNode.VIEW_DIRECTION ) );\n\nexport const viewMatrix = new ShaderNodeObject( new ModelNode( ModelNode.VIEW_MATRIX ) );\n\nexport const cameraPosition = new ShaderNodeObject( new CameraNode( CameraNode.POSITION ) );\n\nexport const diffuseColor = new ShaderNodeObject( new PropertyNode( 'DiffuseColor', 'vec4' ) );\nexport const roughness = new ShaderNodeObject( new PropertyNode( 'Roughness', 'float' ) );\nexport const metalness = new ShaderNodeObject( new PropertyNode( 'Metalness', 'float' ) );\nexport const alphaTest = new ShaderNodeObject( new PropertyNode( 'AlphaTest', 'float' ) );\nexport const specularColor = new ShaderNodeObject( new PropertyNode( 'SpecularColor', 'color' ) );\n\nexport const abs = new ShaderNodeProxy( MathNode, 'abs' );\nexport const acos = new ShaderNodeProxy( MathNode, 'acos' );\nexport const asin = new ShaderNodeProxy( MathNode, 'asin' );\nexport const atan = new ShaderNodeProxy( MathNode, 'atan' );\nexport const ceil = new ShaderNodeProxy( MathNode, 'ceil' );\nexport const clamp = new ShaderNodeProxy( MathNode, 'clamp' );\nexport const cos = new ShaderNodeProxy( MathNode, 'cos' );\nexport const cross = new ShaderNodeProxy( MathNode, 'cross' );\nexport const degrees = new ShaderNodeProxy( MathNode, 'degrees' );\nexport const dFdx = new ShaderNodeProxy( MathNode, 'dFdx' );\nexport const dFdy = new ShaderNodeProxy( MathNode, 'dFdy' );\nexport const distance = new ShaderNodeProxy( MathNode, 'distance' );\nexport const dot = new ShaderNodeProxy( MathNode, 'dot' );\nexport const exp = new ShaderNodeProxy( MathNode, 'exp' );\nexport const exp2 = new ShaderNodeProxy( MathNode, 'exp2' );\nexport const faceforward = new ShaderNodeProxy( MathNode, 'faceforward' );\nexport const floor = new ShaderNodeProxy( MathNode, 'floor' );\nexport const fract = new ShaderNodeProxy( MathNode, 'fract' );\nexport const invert = new ShaderNodeProxy( MathNode, 'invert' );\nexport const inversesqrt = new ShaderNodeProxy( MathNode, 'inversesqrt' );\nexport const length = new ShaderNodeProxy( MathNode, 'length' );\nexport const log = new ShaderNodeProxy( MathNode, 'log' );\nexport const log2 = new ShaderNodeProxy( MathNode, 'log2' );\nexport const max = new ShaderNodeProxy( MathNode, 'max' );\nexport const min = new ShaderNodeProxy( MathNode, 'min' );\nexport const mix = new ShaderNodeProxy( MathNode, 'mix' );\nexport const mod = new ShaderNodeProxy( MathNode, 'mod' );\nexport const negate = new ShaderNodeProxy( MathNode, 'negate' );\nexport const normalize = new ShaderNodeProxy( MathNode, 'normalize' );\nexport const pow = new ShaderNodeProxy( MathNode, 'pow' );\nexport const pow2 = new ShaderNodeProxy( MathNode, 'pow', 2 );\nexport const pow3 = new ShaderNodeProxy( MathNode, 'pow', 3 );\nexport const pow4 = new ShaderNodeProxy( MathNode, 'pow', 4 );\nexport const radians = new ShaderNodeProxy( MathNode, 'radians' );\nexport const reflect = new ShaderNodeProxy( MathNode, 'reflect' );\nexport const refract = new ShaderNodeProxy( MathNode, 'refract' );\nexport const round = new ShaderNodeProxy( MathNode, 'round' );\nexport const saturate = new ShaderNodeProxy( MathNode, 'saturate' );\nexport const sign = new ShaderNodeProxy( MathNode, 'sign' );\nexport const sin = new ShaderNodeProxy( MathNode, 'sin' );\nexport const smoothstep = new ShaderNodeProxy( MathNode, 'smoothstep' );\nexport const sqrt = new ShaderNodeProxy( MathNode, 'sqrt' );\nexport const step = new ShaderNodeProxy( MathNode, 'step' );\nexport const tan = new ShaderNodeProxy( MathNode, 'tan' );\nexport const transformDirection = new ShaderNodeProxy( MathNode, 'transformDirection' );\n\nexport const EPSILON = float( 1e-6 );\nexport const INFINITY = float( 1e6 );\n"],
  "mappings": "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",
  "names": []
}
